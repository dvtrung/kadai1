# 工学部専門科目「プログラミング言語」(2016年度)

## 課題1 (締切 12/2 (金) 23:59)

__計算木__ とは以下のような2分木の一種である．

* 葉 (`leaf`) は計算木である．ただし，葉には正整数が格納されている．
* ふたつの計算木 t1 と t2 に対し，枝 (`branch(t1, t2)`) は計算木である．ただし，枝にはタイプSの枝とタイプTの枝の二種類がある．

この時，枝の価値を以下のように定義する．

* 葉の価値は，格納された整数値そのものである．
* 枝の価値は，タイプSの枝の場合は部分木の価値の和，タイプTの枝の場合は部分木の価値の積である．

### 課題1-1

Java で計算木のデータ構造をオブジェクトを使って定義し，価値を計算するためのメソッド `value` を定義せよ．
以下のインターフェースを元にすること．

### 課題1-2

OCaml で計算木のデータ構造をヴァリアントを使って定義し，価値を計算するための関数 `value_of_tree` を定義せよ．

### 課題1-3(オプション)

課題1-1のプログラムを元にして，計算木の価値を表す計算式(の文字列)に変換するメソッド `toString` を定義せよ．例えば，1を格納した葉と2を格納した葉を部分木として持つタイプSの枝の変換結果は `"(1+2)"`となる．積については `*` を使うこと．簡単のために枝を表す式毎に括弧をつけよ．

注意: 単に木の価値を計算してからその結果(この例であれば `"3"`) を表示するのは認めない．(葉に格納された数値は全て文字列に含まれるようにせよ．)

### 課題1-4(オプション)

課題1-3のプログラムを元にして，括弧を適宜省いた文字列に変換するようなメソッドを(名前を別にして)定義せよ．この時(いつもの算数の通り) `*` は `+` より結合が強く，どちらも左結合であると考える．すなわち

* `"((2*4)+3)"` → `"2*4+3"` はOK
* `"((2+4)*3)"` → `"2+4*3"` はダメ
* `"((2+4)*3)"` → `"(2+4)*3"` はOK
* `"((1+2)+3)"` → `"1+2+3"` はOK
* `"(1+(2+3))"` → `"1+2+3"` はダメ
* `"(1+(2+3))"` → `"1+(2+3)"` はOK
* `"((1*2)*3)"` → `"1*2*3"` はOK
* `"(1*(2*3))"` → `"1*2*3"` はダメ
* `"(1*(2*3))"` → `"1*(2*3)"` はOK

### 課題1-5(オプション)

課題1-1のプログラムを元にして，以下のような「木の簡約操作」を行うようなメソッド `reduce` を定義せよ．

> 簡約操作: ふたつの葉を部分木として持つ枝一箇所を適当に選んで，その部分木を，その部分木の価値を格納した葉で置換する


### 課題1-6(オプション)

課題1-2のプログラムを元にして，計算木の価値を表す計算式(の文字列)に変換する関数 `string_of_tree` を定義せよ．OCaml での文字列の連結に `^` を使う．

```{.ocaml}
# let s1 = "This is ";;
val s1 : string = "This is "
# s1 ^ "a pen.";;
- : string = "This is a pen."
```

その他の注意は課題1-3と同じである．

### 課題1-7(オプション)

課題1-6のプログラムを元にして，括弧を適宜省いた文字列に変換するような関数を(名前を別にして)定義せよ．その他の注意は課題1-4と同じである．

### 課題1-5(オプション)

課題1-2のプログラムを元にして，課題1-5にある「木の簡約操作」を行うような関数 `reduce` を定義せよ．
